/*
Nessie API

Transactional Catalog for Data Lakes  * Git-inspired data version control * Cross-table transactions and visibility * Works with Apache Iceberg tables

API version: 0.104.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"encoding/json"
	"fmt"
)

// checks if the Content type satisfies the MappedNullable interface at compile time
var _ MappedNullable = &Content{}

// Content struct for Content
type Content struct {
	DeltaLakeTable *DeltaLakeTable
	IcebergTable *IcebergTable
	IcebergView *IcebergView
	Namespace *Namespace
	UDF *UDF
	MapmapOfStringAny *map[string]interface{}
}

// Unmarshal JSON data into any of the pointers in the struct
func (dst *Content) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = json.Unmarshal(data, &jsonDict)
	if err != nil {
		return fmt.Errorf("failed to unmarshal JSON into map for the discriminator lookup")
	}

	// check if the discriminator value is 'DELTA_LAKE_TABLE'
	if jsonDict["type"] == "DELTA_LAKE_TABLE" {
		// try to unmarshal JSON data into DeltaLakeTable
		err = json.Unmarshal(data, &dst.DeltaLakeTable);
		if err == nil {
			jsonDeltaLakeTable, _ := json.Marshal(dst.DeltaLakeTable)
			if string(jsonDeltaLakeTable) == "{}" { // empty struct
				dst.DeltaLakeTable = nil
			} else {
				return nil // data stored in dst.DeltaLakeTable, return on the first match
			}
		} else {
			dst.DeltaLakeTable = nil
		}
	}

	// check if the discriminator value is 'ICEBERG_TABLE'
	if jsonDict["type"] == "ICEBERG_TABLE" {
		// try to unmarshal JSON data into IcebergTable
		err = json.Unmarshal(data, &dst.IcebergTable);
		if err == nil {
			jsonIcebergTable, _ := json.Marshal(dst.IcebergTable)
			if string(jsonIcebergTable) == "{}" { // empty struct
				dst.IcebergTable = nil
			} else {
				return nil // data stored in dst.IcebergTable, return on the first match
			}
		} else {
			dst.IcebergTable = nil
		}
	}

	// check if the discriminator value is 'ICEBERG_VIEW'
	if jsonDict["type"] == "ICEBERG_VIEW" {
		// try to unmarshal JSON data into IcebergView
		err = json.Unmarshal(data, &dst.IcebergView);
		if err == nil {
			jsonIcebergView, _ := json.Marshal(dst.IcebergView)
			if string(jsonIcebergView) == "{}" { // empty struct
				dst.IcebergView = nil
			} else {
				return nil // data stored in dst.IcebergView, return on the first match
			}
		} else {
			dst.IcebergView = nil
		}
	}

	// check if the discriminator value is 'NAMESPACE'
	if jsonDict["type"] == "NAMESPACE" {
		// try to unmarshal JSON data into Namespace
		err = json.Unmarshal(data, &dst.Namespace);
		if err == nil {
			jsonNamespace, _ := json.Marshal(dst.Namespace)
			if string(jsonNamespace) == "{}" { // empty struct
				dst.Namespace = nil
			} else {
				return nil // data stored in dst.Namespace, return on the first match
			}
		} else {
			dst.Namespace = nil
		}
	}

	// check if the discriminator value is 'UDF'
	if jsonDict["type"] == "UDF" {
		// try to unmarshal JSON data into UDF
		err = json.Unmarshal(data, &dst.UDF);
		if err == nil {
			jsonUDF, _ := json.Marshal(dst.UDF)
			if string(jsonUDF) == "{}" { // empty struct
				dst.UDF = nil
			} else {
				return nil // data stored in dst.UDF, return on the first match
			}
		} else {
			dst.UDF = nil
		}
	}

	// try to unmarshal JSON data into DeltaLakeTable
	err = json.Unmarshal(data, &dst.DeltaLakeTable);
	if err == nil {
		jsonDeltaLakeTable, _ := json.Marshal(dst.DeltaLakeTable)
		if string(jsonDeltaLakeTable) == "{}" { // empty struct
			dst.DeltaLakeTable = nil
		} else {
			return nil // data stored in dst.DeltaLakeTable, return on the first match
		}
	} else {
		dst.DeltaLakeTable = nil
	}

	// try to unmarshal JSON data into IcebergTable
	err = json.Unmarshal(data, &dst.IcebergTable);
	if err == nil {
		jsonIcebergTable, _ := json.Marshal(dst.IcebergTable)
		if string(jsonIcebergTable) == "{}" { // empty struct
			dst.IcebergTable = nil
		} else {
			return nil // data stored in dst.IcebergTable, return on the first match
		}
	} else {
		dst.IcebergTable = nil
	}

	// try to unmarshal JSON data into IcebergView
	err = json.Unmarshal(data, &dst.IcebergView);
	if err == nil {
		jsonIcebergView, _ := json.Marshal(dst.IcebergView)
		if string(jsonIcebergView) == "{}" { // empty struct
			dst.IcebergView = nil
		} else {
			return nil // data stored in dst.IcebergView, return on the first match
		}
	} else {
		dst.IcebergView = nil
	}

	// try to unmarshal JSON data into Namespace
	err = json.Unmarshal(data, &dst.Namespace);
	if err == nil {
		jsonNamespace, _ := json.Marshal(dst.Namespace)
		if string(jsonNamespace) == "{}" { // empty struct
			dst.Namespace = nil
		} else {
			return nil // data stored in dst.Namespace, return on the first match
		}
	} else {
		dst.Namespace = nil
	}

	// try to unmarshal JSON data into UDF
	err = json.Unmarshal(data, &dst.UDF);
	if err == nil {
		jsonUDF, _ := json.Marshal(dst.UDF)
		if string(jsonUDF) == "{}" { // empty struct
			dst.UDF = nil
		} else {
			return nil // data stored in dst.UDF, return on the first match
		}
	} else {
		dst.UDF = nil
	}

	// try to unmarshal JSON data into MapmapOfStringAny
	err = json.Unmarshal(data, &dst.MapmapOfStringAny);
	if err == nil {
		jsonMapmapOfStringAny, _ := json.Marshal(dst.MapmapOfStringAny)
		if string(jsonMapmapOfStringAny) == "{}" { // empty struct
			dst.MapmapOfStringAny = nil
		} else {
			return nil // data stored in dst.MapmapOfStringAny, return on the first match
		}
	} else {
		dst.MapmapOfStringAny = nil
	}

	return fmt.Errorf("data failed to match schemas in anyOf(Content)")
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src Content) MarshalJSON() ([]byte, error) {
	if src.DeltaLakeTable != nil {
		return json.Marshal(&src.DeltaLakeTable)
	}

	if src.IcebergTable != nil {
		return json.Marshal(&src.IcebergTable)
	}

	if src.IcebergView != nil {
		return json.Marshal(&src.IcebergView)
	}

	if src.Namespace != nil {
		return json.Marshal(&src.Namespace)
	}

	if src.UDF != nil {
		return json.Marshal(&src.UDF)
	}

	if src.MapmapOfStringAny != nil {
		return json.Marshal(&src.MapmapOfStringAny)
	}

	return nil, nil // no data in anyOf schemas
}

func (src Content) ToMap() (map[string]interface{}, error) {
	if src.DeltaLakeTable != nil {
		return src.DeltaLakeTable.ToMap()
	}

	if src.IcebergTable != nil {
		return src.IcebergTable.ToMap()
	}

	if src.IcebergView != nil {
		return src.IcebergView.ToMap()
	}

	if src.Namespace != nil {
		return src.Namespace.ToMap()
	}

	if src.UDF != nil {
		return src.UDF.ToMap()
	}

	if src.MapmapOfStringAny != nil {
		return *src.MapmapOfStringAny, nil
	}

    return nil, nil // no data in anyOf schemas
}

type NullableContent struct {
	value *Content
	isSet bool
}

func (v NullableContent) Get() *Content {
	return v.value
}

func (v *NullableContent) Set(val *Content) {
	v.value = val
	v.isSet = true
}

func (v NullableContent) IsSet() bool {
	return v.isSet
}

func (v *NullableContent) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableContent(val *Content) *NullableContent {
	return &NullableContent{value: val, isSet: true}
}

func (v NullableContent) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableContent) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}


